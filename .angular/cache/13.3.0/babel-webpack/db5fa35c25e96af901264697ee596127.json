{"ast":null,"code":"import { ElementRef, EventEmitter } from '@angular/core';\nimport { FormControl } from '@angular/forms';\nimport { BehaviorSubject } from 'rxjs';\nimport { MAT_KEYBOARD_DEADKEYS } from '../../configs/keyboard-deadkey.config';\nimport { KeyboardClassKey } from '../../enums/keyboard-class-key.enum';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/material/button\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"@angular/material/icon\";\n\nfunction MatKeyboardKeyComponent_mat_icon_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-icon\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"fontSet\", ctx_r0.fontSet)(\"fontIcon\", ctx_r0.fontIcon)(\"svgIcon\", ctx_r0.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.iconName);\n  }\n}\n\nfunction MatKeyboardKeyComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate(ctx_r2.key);\n  }\n}\n\nexport const VALUE_NEWLINE = '\\n\\r';\nexport const VALUE_SPACE = ' ';\nexport const VALUE_TAB = '\\t';\nconst REPEAT_TIMEOUT = 500;\nconst REPEAT_INTERVAL = 100;\nexport let MatKeyboardKeyComponent = /*#__PURE__*/(() => {\n  class MatKeyboardKeyComponent {\n    // Inject dependencies\n    constructor(_deadkeys) {\n      this._deadkeys = _deadkeys;\n      this._deadkeyKeys = [];\n      this._repeatState = false; // true if repeating, false if waiting\n\n      this.active$ = new BehaviorSubject(false);\n      this.pressed$ = new BehaviorSubject(false);\n      this.genericClick = new EventEmitter();\n      this.enterClick = new EventEmitter();\n      this.bkspClick = new EventEmitter();\n      this.capsClick = new EventEmitter();\n      this.altClick = new EventEmitter();\n      this.shiftClick = new EventEmitter();\n      this.spaceClick = new EventEmitter();\n      this.tabClick = new EventEmitter();\n      this.keyClick = new EventEmitter();\n    }\n\n    set active(active) {\n      this.active$.next(active);\n    }\n\n    get active() {\n      return this.active$.getValue();\n    }\n\n    set pressed(pressed) {\n      this.pressed$.next(pressed);\n    }\n\n    get pressed() {\n      return this.pressed$.getValue();\n    }\n\n    get lowerKey() {\n      return `${this.key}`.toLowerCase();\n    }\n\n    get charCode() {\n      return `${this.key}`.charCodeAt(0);\n    }\n\n    get isClassKey() {\n      return this.key in KeyboardClassKey;\n    }\n\n    get isDeadKey() {\n      return this._deadkeyKeys.some(deadKey => deadKey === `${this.key}`);\n    }\n\n    get hasIcon() {\n      return this.icon !== undefined && this.icon !== null;\n    }\n\n    get iconName() {\n      return this.icon.name || '';\n    }\n\n    get fontSet() {\n      return this.icon.fontSet || '';\n    }\n\n    get fontIcon() {\n      return this.icon.fontIcon || '';\n    }\n\n    get svgIcon() {\n      return this.icon.svgIcon || '';\n    }\n\n    get cssClass() {\n      const classes = [];\n\n      if (this.hasIcon) {\n        classes.push('mat-keyboard-key-modifier');\n        classes.push(`mat-keyboard-key-${this.lowerKey}`);\n      }\n\n      if (this.isDeadKey) {\n        classes.push('mat-keyboard-key-deadkey');\n      }\n\n      return classes.join(' ');\n    }\n\n    get inputValue() {\n      if (this.control) {\n        return this.control.value;\n      } else if (this.input && this.input.nativeElement && this.input.nativeElement.value) {\n        return this.input.nativeElement.value;\n      } else {\n        return '';\n      }\n    }\n\n    set inputValue(inputValue) {\n      if (this.control) {\n        this.control.setValue(inputValue);\n      } else if (this.input && this.input.nativeElement) {\n        this.input.nativeElement.value = inputValue;\n      }\n    }\n\n    ngOnInit() {\n      // read the deadkeys\n      this._deadkeyKeys = Object.keys(this._deadkeys);\n    }\n\n    ngOnDestroy() {\n      this.cancelRepeat();\n    }\n\n    onClick(event) {\n      // Trigger generic click event\n      this.genericClick.emit(event); // Do not execute keypress if key is currently repeating\n\n      if (this._repeatState) {\n        return;\n      } // Trigger a global key event. TODO: investigate\n      // this._triggerKeyEvent();\n      // Manipulate the focused input / textarea value\n\n\n      const caret = this.input ? this._getCursorPosition() : 0;\n      let char;\n\n      switch (this.key) {\n        // this keys have no actions yet\n        // TODO: add deadkeys and modifiers\n        case KeyboardClassKey.Alt:\n        case KeyboardClassKey.AltGr:\n        case KeyboardClassKey.AltLk:\n          this.altClick.emit(event);\n          break;\n\n        case KeyboardClassKey.Bksp:\n          this.deleteSelectedText();\n          this.bkspClick.emit(event);\n          break;\n\n        case KeyboardClassKey.Caps:\n          this.capsClick.emit(event);\n          break;\n\n        case KeyboardClassKey.Enter:\n          if (this._isTextarea()) {\n            char = VALUE_NEWLINE;\n          } else {\n            this.enterClick.emit(event); // TODO: trigger submit / onSubmit / ngSubmit properly (for the time being this has to be handled by the user himself)\n            // console.log(this.control.ngControl.control.root)\n            // this.input.nativeElement.form.submit();\n          }\n\n          break;\n\n        case KeyboardClassKey.Shift:\n          this.shiftClick.emit(event);\n          break;\n\n        case KeyboardClassKey.Space:\n          char = VALUE_SPACE;\n          this.spaceClick.emit(event);\n          break;\n\n        case KeyboardClassKey.Tab:\n          char = VALUE_TAB;\n          this.tabClick.emit(event);\n          break;\n\n        default:\n          // the key is not mapped or a string\n          char = `${this.key}`;\n          this.keyClick.emit(event);\n          break;\n      }\n\n      if (char && this.input) {\n        this.replaceSelectedText(char);\n\n        this._setCursorPosition(caret + 1);\n      } // Dispatch Input Event for Angular to register a change\n\n\n      if (this.input && this.input.nativeElement) {\n        setTimeout(() => {\n          this.input.nativeElement.dispatchEvent(new Event('input', {\n            bubbles: true\n          }));\n        });\n      }\n    } // Handle repeating keys. Keypress logic derived from onClick()\n\n\n    onPointerDown() {\n      this.cancelRepeat();\n      this._repeatState = false;\n      this._repeatTimeoutHandler = setTimeout(() => {\n        // Initialize keypress variables\n        let char;\n        let keyFn;\n\n        switch (this.key) {\n          // Ignore non-repeating keys\n          case KeyboardClassKey.Alt:\n          case KeyboardClassKey.AltGr:\n          case KeyboardClassKey.AltLk:\n          case KeyboardClassKey.Caps:\n          case KeyboardClassKey.Enter:\n          case KeyboardClassKey.Shift:\n            return;\n\n          case KeyboardClassKey.Bksp:\n            keyFn = () => {\n              this.deleteSelectedText();\n              this.bkspClick.emit();\n            };\n\n            break;\n\n          case KeyboardClassKey.Space:\n            char = VALUE_SPACE;\n\n            keyFn = () => this.spaceClick.emit();\n\n            break;\n\n          case KeyboardClassKey.Tab:\n            char = VALUE_TAB;\n\n            keyFn = () => this.tabClick.emit();\n\n            break;\n\n          default:\n            char = `${this.key}`;\n\n            keyFn = () => this.keyClick.emit();\n\n            break;\n        } // Execute repeating keypress\n\n\n        this._repeatIntervalHandler = setInterval(() => {\n          const caret = this.input ? this._getCursorPosition() : 0;\n          this._repeatState = true;\n\n          if (keyFn) {\n            keyFn();\n          }\n\n          if (char && this.input) {\n            this.replaceSelectedText(char);\n\n            this._setCursorPosition(caret + 1);\n          }\n\n          if (this.input && this.input.nativeElement) {\n            setTimeout(() => this.input.nativeElement.dispatchEvent(new Event('input', {\n              bubbles: true\n            })));\n          }\n        }, REPEAT_INTERVAL);\n      }, REPEAT_TIMEOUT);\n    }\n\n    cancelRepeat() {\n      if (this._repeatTimeoutHandler) {\n        clearTimeout(this._repeatTimeoutHandler);\n        this._repeatTimeoutHandler = null;\n      }\n\n      if (this._repeatIntervalHandler) {\n        clearInterval(this._repeatIntervalHandler);\n        this._repeatIntervalHandler = null;\n      }\n    }\n\n    deleteSelectedText() {\n      const value = this.inputValue ? this.inputValue.toString() : '';\n      let caret = this.input ? this._getCursorPosition() : 0;\n\n      let selectionLength = this._getSelectionLength();\n\n      if (selectionLength === 0) {\n        if (caret === 0) {\n          return;\n        }\n\n        caret--;\n        selectionLength = 1;\n      }\n\n      const headPart = value.slice(0, caret);\n      const endPart = value.slice(caret + selectionLength);\n      this.inputValue = [headPart, endPart].join('');\n\n      this._setCursorPosition(caret);\n    }\n\n    replaceSelectedText(char) {\n      const value = this.inputValue ? this.inputValue.toString() : '';\n      const caret = this.input ? this._getCursorPosition() : 0;\n\n      const selectionLength = this._getSelectionLength();\n\n      const headPart = value.slice(0, caret);\n      const endPart = value.slice(caret + selectionLength);\n      this.inputValue = [headPart, char, endPart].join('');\n    } // TODO: Include for repeating keys as well (if this gets implemented)\n    // private _triggerKeyEvent(): Event {\n    //   const keyboardEvent = new KeyboardEvent('keydown');\n    //   //\n    //   // keyboardEvent[initMethod](\n    //   //   true, // bubbles\n    //   //   true, // cancelable\n    //   //   window, // viewArg: should be window\n    //   //   false, // ctrlKeyArg\n    //   //   false, // altKeyArg\n    //   //   false, // shiftKeyArg\n    //   //   false, // metaKeyArg\n    //   //   this.charCode, // keyCodeArg : unsigned long - the virtual key code, else 0\n    //   //   0 // charCodeArgs : unsigned long - the Unicode character associated with the depressed key, else 0\n    //   // );\n    //   //\n    //   // window.document.dispatchEvent(keyboardEvent);\n    //   return keyboardEvent;\n    // }\n    // inspired by:\n    // ref https://stackoverflow.com/a/2897510/1146207\n\n\n    _getCursorPosition() {\n      if (!this.input) {\n        return;\n      }\n\n      if ('selectionStart' in this.input.nativeElement) {\n        // Standard-compliant browsers\n        return this.input.nativeElement.selectionStart;\n      } else if ('selection' in window.document) {\n        // IE\n        this.input.nativeElement.focus();\n        const selection = window.document['selection'];\n        const sel = selection.createRange();\n        const selLen = selection.createRange().text.length;\n        sel.moveStart('character', -this.control.value.length);\n        return sel.text.length - selLen;\n      }\n    }\n\n    _getSelectionLength() {\n      if (!this.input) {\n        return;\n      }\n\n      if ('selectionEnd' in this.input.nativeElement) {\n        // Standard-compliant browsers\n        return this.input.nativeElement.selectionEnd - this.input.nativeElement.selectionStart;\n      }\n\n      if ('selection' in window.document) {\n        // IE\n        this.input.nativeElement.focus();\n        const selection = window.document['selection'];\n        return selection.createRange().text.length;\n      }\n    } // inspired by:\n    // ref https://stackoverflow.com/a/12518737/1146207\n    // tslint:disable one-line\n\n\n    _setCursorPosition(position) {\n      if (!this.input) {\n        return;\n      }\n\n      this.inputValue = this.control.value; // ^ this is used to not only get \"focus\", but\n      // to make sure we don't have it everything -selected-\n      // (it causes an issue in chrome, and having it doesn't hurt any other browser)\n\n      if ('createTextRange' in this.input.nativeElement) {\n        const range = this.input.nativeElement.createTextRange();\n        range.move('character', position);\n        range.select();\n        return true;\n      } else {\n        // (el.selectionStart === 0 added for Firefox bug)\n        if (this.input.nativeElement.selectionStart || this.input.nativeElement.selectionStart === 0) {\n          this.input.nativeElement.focus();\n          this.input.nativeElement.setSelectionRange(position, position);\n          return true;\n        } // fail city, fortunately this never happens (as far as I've tested) :)\n        else {\n          this.input.nativeElement.focus();\n          return false;\n        }\n      }\n    }\n\n    _isTextarea() {\n      return this.input && this.input.nativeElement && this.input.nativeElement.tagName === 'TEXTAREA';\n    }\n\n  }\n\n  MatKeyboardKeyComponent.ɵfac = function MatKeyboardKeyComponent_Factory(t) {\n    return new (t || MatKeyboardKeyComponent)(i0.ɵɵdirectiveInject(MAT_KEYBOARD_DEADKEYS));\n  };\n\n  MatKeyboardKeyComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: MatKeyboardKeyComponent,\n    selectors: [[\"mat-keyboard-key\"]],\n    inputs: {\n      key: \"key\",\n      icon: \"icon\",\n      active: \"active\",\n      pressed: \"pressed\",\n      input: \"input\",\n      control: \"control\"\n    },\n    outputs: {\n      genericClick: \"genericClick\",\n      enterClick: \"enterClick\",\n      bkspClick: \"bkspClick\",\n      capsClick: \"capsClick\",\n      altClick: \"altClick\",\n      shiftClick: \"shiftClick\",\n      spaceClick: \"spaceClick\",\n      tabClick: \"tabClick\",\n      keyClick: \"keyClick\"\n    },\n    decls: 6,\n    vars: 11,\n    consts: [[\"mat-raised-button\", \"\", \"tabindex\", \"-1\", 1, \"mat-keyboard-key\", 3, \"ngClass\", \"click\", \"pointerdown\", \"pointerleave\", \"pointerup\"], [3, \"fontSet\", \"fontIcon\", \"svgIcon\", 4, \"ngIf\", \"ngIfElse\"], [\"noIcon\", \"\"], [3, \"fontSet\", \"fontIcon\", \"svgIcon\"]],\n    template: function MatKeyboardKeyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function MatKeyboardKeyComponent_Template_button_click_0_listener($event) {\n          return ctx.onClick($event);\n        })(\"pointerdown\", function MatKeyboardKeyComponent_Template_button_pointerdown_0_listener() {\n          return ctx.onPointerDown();\n        })(\"pointerleave\", function MatKeyboardKeyComponent_Template_button_pointerleave_0_listener() {\n          return ctx.cancelRepeat();\n        })(\"pointerup\", function MatKeyboardKeyComponent_Template_button_pointerup_0_listener() {\n          return ctx.cancelRepeat();\n        });\n        i0.ɵɵpipe(1, \"async\");\n        i0.ɵɵpipe(2, \"async\");\n        i0.ɵɵtemplate(3, MatKeyboardKeyComponent_mat_icon_3_Template, 2, 4, \"mat-icon\", 1);\n        i0.ɵɵtemplate(4, MatKeyboardKeyComponent_ng_template_4_Template, 1, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(5);\n\n        i0.ɵɵclassProp(\"mat-keyboard-key-active\", i0.ɵɵpipeBind1(1, 7, ctx.active$))(\"mat-keyboard-key-pressed\", i0.ɵɵpipeBind1(2, 9, ctx.pressed$));\n        i0.ɵɵproperty(\"ngClass\", ctx.cssClass);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasIcon)(\"ngIfElse\", _r1);\n      }\n    },\n    directives: [i1.MatButton, i2.NgClass, i2.NgIf, i3.MatIcon],\n    pipes: [i2.AsyncPipe],\n    styles: [\"@charset \\\"UTF-8\\\";[_nghost-%COMP%]{display:flex;font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;justify-content:space-between;line-height:20px}.mat-keyboard-key[_ngcontent-%COMP%]{min-width:0;width:100%}.mat-keyboard-key-active[_ngcontent-%COMP%]{background-color:#e0e0e0}.mat-keyboard-key-pressed[_ngcontent-%COMP%]{background-color:#bdbdbd}.mat-keyboard-key-capslock[_ngcontent-%COMP%]{background-color:#fff}.mat-keyboard-key-capslock[_ngcontent-%COMP%]:before{background-color:#bdbdbd;border-radius:100%;content:\\\"\\\";display:inline-block;height:3px;left:5px;position:absolute;top:5px;transition:.4s cubic-bezier(.25,.8,.25,1);transition-property:background-color,box-shadow;width:3px}.mat-keyboard-key-capslock.mat-keyboard-key-active[_ngcontent-%COMP%]:before{background-color:#0f0;box-shadow:0 0 \\\\a7px #adff2f}.dark-theme[_nghost-%COMP%]   .mat-keyboard-key[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .mat-keyboard-key[_ngcontent-%COMP%]{background-color:#616161;color:#f5f5f5}.dark-theme[_nghost-%COMP%]   .mat-keyboard-key-active[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .mat-keyboard-key-active[_ngcontent-%COMP%]{background-color:#9e9e9e}.dark-theme[_nghost-%COMP%]   .mat-keyboard-key-pressed[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .mat-keyboard-key-pressed[_ngcontent-%COMP%]{background-color:#757575}.debug[_nghost-%COMP%]   .mat-keyboard-key-deadkey[_ngcontent-%COMP%], .debug   [_nghost-%COMP%]   .mat-keyboard-key-deadkey[_ngcontent-%COMP%]{background-color:#5f9ea0}.debug[_nghost-%COMP%]   .mat-keyboard-key-deadkey.mat-keyboard-key-active[_ngcontent-%COMP%], .debug   [_nghost-%COMP%]   .mat-keyboard-key-deadkey.mat-keyboard-key-active[_ngcontent-%COMP%]{background-color:#6fa8aa}.debug[_nghost-%COMP%]   .mat-keyboard-key-deadkey.mat-keyboard-key-pressed[_ngcontent-%COMP%], .debug   [_nghost-%COMP%]   .mat-keyboard-key-deadkey.mat-keyboard-key-pressed[_ngcontent-%COMP%]{background-color:#7fb1b3}.debug[_nghost-%COMP%]   .mat-keyboard-key-modifier[_ngcontent-%COMP%], .debug   [_nghost-%COMP%]   .mat-keyboard-key-modifier[_ngcontent-%COMP%]{background-color:#7fffd4}.debug[_nghost-%COMP%]   .mat-keyboard-key-modifier.mat-keyboard-key-active[_ngcontent-%COMP%], .debug   [_nghost-%COMP%]   .mat-keyboard-key-modifier.mat-keyboard-key-active[_ngcontent-%COMP%]{background-color:#9fd}.debug[_nghost-%COMP%]   .mat-keyboard-key-modifier.mat-keyboard-key-pressed[_ngcontent-%COMP%], .debug   [_nghost-%COMP%]   .mat-keyboard-key-modifier.mat-keyboard-key-pressed[_ngcontent-%COMP%]{background-color:#b2ffe5}.dark-theme.debug[_nghost-%COMP%]   .mat-keyboard-key-deadkey[_ngcontent-%COMP%], .dark-theme.debug   [_nghost-%COMP%]   .mat-keyboard-key-deadkey[_ngcontent-%COMP%]{background-color:#639}.dark-theme.debug[_nghost-%COMP%]   .mat-keyboard-key-deadkey.mat-keyboard-key-active[_ngcontent-%COMP%], .dark-theme.debug   [_nghost-%COMP%]   .mat-keyboard-key-deadkey.mat-keyboard-key-active[_ngcontent-%COMP%]{background-color:#7339ac}.dark-theme.debug[_nghost-%COMP%]   .mat-keyboard-key-deadkey.mat-keyboard-key-pressed[_ngcontent-%COMP%], .dark-theme.debug   [_nghost-%COMP%]   .mat-keyboard-key-deadkey.mat-keyboard-key-pressed[_ngcontent-%COMP%]{background-color:#8040bf}.dark-theme.debug[_nghost-%COMP%]   .mat-keyboard-key-modifier[_ngcontent-%COMP%], .dark-theme.debug   [_nghost-%COMP%]   .mat-keyboard-key-modifier[_ngcontent-%COMP%]{background-color:#9370db}.dark-theme.debug[_nghost-%COMP%]   .mat-keyboard-key-modifier.mat-keyboard-key-active[_ngcontent-%COMP%], .dark-theme.debug   [_nghost-%COMP%]   .mat-keyboard-key-modifier.mat-keyboard-key-active[_ngcontent-%COMP%]{background-color:#a284e0}.dark-theme.debug[_nghost-%COMP%]   .mat-keyboard-key-modifier.mat-keyboard-key-pressed[_ngcontent-%COMP%], .dark-theme.debug   [_nghost-%COMP%]   .mat-keyboard-key-modifier.mat-keyboard-key-pressed[_ngcontent-%COMP%]{background-color:#b299e5}\"],\n    changeDetection: 0\n  });\n  return MatKeyboardKeyComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}