{"ast":null,"code":"import { LiveAnnouncer } from '@angular/cdk/a11y';\nimport { Overlay, OverlayConfig } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { ComponentRef, LOCALE_ID } from '@angular/core';\nimport { MatKeyboardRef } from '../classes/keyboard-ref.class';\nimport { MatKeyboardContainerComponent } from '../components/keyboard-container/keyboard-container.component';\nimport { MatKeyboardComponent } from '../components/keyboard/keyboard.component';\nimport { MAT_KEYBOARD_LAYOUTS } from '../configs/keyboard-layouts.config';\nimport { _applyAvailableLayouts, _applyConfigDefaults } from '../utils/keyboard.utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/cdk/overlay\";\nimport * as i2 from \"@angular/cdk/a11y\";\n/**\r\n * Service to dispatch Material Design keyboard.\r\n */\n\nexport let MatKeyboardService = /*#__PURE__*/(() => {\n  class MatKeyboardService {\n    constructor(_overlay, _live, _defaultLocale, _layouts, _parentKeyboard) {\n      this._overlay = _overlay;\n      this._live = _live;\n      this._defaultLocale = _defaultLocale;\n      this._layouts = _layouts;\n      this._parentKeyboard = _parentKeyboard;\n      /**\r\n       * Reference to the current keyboard in the view *at this level* (in the Angular injector tree).\r\n       * If there is a parent keyboard service, all operations should delegate to that parent\r\n       * via `_openedKeyboardRef`.\r\n       */\n\n      this._keyboardRefAtThisLevel = null;\n      this._availableLocales = {}; // prepare available layouts mapping\n\n      this._availableLocales = _applyAvailableLayouts(_layouts);\n    }\n    /** Reference to the currently opened keyboard at *any* level. */\n\n\n    get _openedKeyboardRef() {\n      const parent = this._parentKeyboard;\n      return parent ? parent._openedKeyboardRef : this._keyboardRefAtThisLevel;\n    }\n\n    set _openedKeyboardRef(value) {\n      if (this._parentKeyboard) {\n        this._parentKeyboard._openedKeyboardRef = value;\n      } else {\n        this._keyboardRefAtThisLevel = value;\n      }\n    }\n\n    get availableLocales() {\n      return this._availableLocales;\n    }\n\n    get isOpened() {\n      return !!this._openedKeyboardRef;\n    }\n    /**\r\n     * Creates and dispatches a keyboard with a custom component for the content, removing any\r\n     * currently opened keyboards.\r\n     *\r\n     * @param layoutOrLocale layout or locale to use.\r\n     * @param config Extra configuration for the keyboard.\r\n     */\n\n\n    openFromComponent(layoutOrLocale, config) {\n      const keyboardRef = this._attachKeyboardContent(config);\n\n      keyboardRef.instance.darkTheme = config.darkTheme;\n      keyboardRef.instance.isDebug = config.isDebug; // a locale is provided\n\n      if (this.availableLocales[layoutOrLocale]) {\n        keyboardRef.instance.locale = layoutOrLocale;\n        keyboardRef.instance.layout = this.getLayoutForLocale(layoutOrLocale);\n      } // a layout name is provided\n\n\n      if (this._layouts[layoutOrLocale]) {\n        keyboardRef.instance.layout = this._layouts[layoutOrLocale];\n        keyboardRef.instance.locale = this._layouts[layoutOrLocale].lang && this._layouts[layoutOrLocale].lang.pop();\n      }\n\n      if (config.customIcons) {\n        keyboardRef.instance.icons = config.customIcons;\n      } // When the keyboard is dismissed, lower the keyboard counter.\n\n\n      keyboardRef.afterDismissed().subscribe(() => {\n        // Clear the keyboard ref if it hasn't already been replaced by a newer keyboard.\n        if (this._openedKeyboardRef === keyboardRef) {\n          this._openedKeyboardRef = null;\n        }\n      });\n\n      if (this._openedKeyboardRef) {\n        // If a keyboard is already in view, dismiss it and enter the\n        // new keyboard after exit animation is complete.\n        this._openedKeyboardRef.afterDismissed().subscribe(() => {\n          keyboardRef.containerInstance.enter();\n        });\n\n        this._openedKeyboardRef.dismiss();\n      } else {\n        // If no keyboard is in view, enter the new keyboard.\n        keyboardRef.containerInstance.enter();\n      } // If a dismiss timeout is provided, set up dismiss based on after the keyboard is opened.\n      // if (configs.duration > 0) {\n      //   keyboardRef.afterOpened().subscribe(() => {\n      //     setTimeout(() => keyboardRef.dismiss(), configs.duration);\n      //   });\n      // }\n\n\n      if (config.announcementMessage) {\n        this._live.announce(config.announcementMessage, config.politeness);\n      }\n\n      this._openedKeyboardRef = keyboardRef;\n      return this._openedKeyboardRef;\n    }\n    /**\r\n     * Opens a keyboard with a message and an optional action.\r\n     * @param layoutOrLocale A string representing the locale or the layout name to be used.\r\n     * @param config Additional configuration options for the keyboard.\r\n     */\n\n\n    open(layoutOrLocale = this._defaultLocale, config = {}, anchor = 'bottom') {\n      const _config = _applyConfigDefaults(config);\n\n      this._anchor = anchor;\n      return this.openFromComponent(layoutOrLocale, _config);\n    }\n    /**\r\n     * Dismisses the currently-visible keyboard.\r\n     */\n\n\n    dismiss() {\n      if (this._openedKeyboardRef) {\n        this._openedKeyboardRef.dismiss();\n      }\n    }\n    /**\r\n     * Map a given locale to a layout name.\r\n     * @param locale The layout name\r\n     */\n\n\n    mapLocale(locale = this._defaultLocale) {\n      let layout;\n      const country = locale.split('-').shift(); // search for layout matching the\n      // first part, the country code\n\n      if (this.availableLocales[country]) {\n        layout = this.availableLocales[locale];\n      } // look if the detailed locale matches any layout\n\n\n      if (this.availableLocales[locale]) {\n        layout = this.availableLocales[locale];\n      }\n\n      if (!layout) {\n        throw Error(`No layout found for locale ${locale}`);\n      }\n\n      return layout;\n    }\n\n    getLayoutForLocale(locale) {\n      return this._layouts[this.mapLocale(locale)];\n    }\n    /**\r\n     * Attaches the keyboard container component to the overlay.\r\n     */\n\n\n    _attachKeyboardContainer(overlayRef, config) {\n      const containerPortal = new ComponentPortal(MatKeyboardContainerComponent, config.viewContainerRef);\n      const containerRef = overlayRef.attach(containerPortal); // set config\n\n      containerRef.instance.keyboardConfig = config;\n      return containerRef.instance;\n    }\n    /**\r\n     * Places a new component as the content of the keyboard container.\r\n     */\n\n\n    _attachKeyboardContent(config) {\n      const overlayRef = this._createOverlay(); // this.realignToAnchor(overlayRef);\n\n\n      const container = this._attachKeyboardContainer(overlayRef, config);\n\n      const portal = new ComponentPortal(MatKeyboardComponent);\n      const contentRef = container.attachComponentPortal(portal);\n      return new MatKeyboardRef(contentRef.instance, container, overlayRef);\n    }\n    /**\r\n     * Creates a new overlay and places it in the correct location.\r\n     */\n\n\n    _createOverlay() {\n      const state = new OverlayConfig({\n        width: '100%'\n      }); // const popoverConfig: PopoverConfig = {\n      //   horizontalAlign: this._popover.horizontalAlign,\n      //   verticalAlign: this._popover.verticalAlign,\n      //   hasBackdrop: this._popover.hasBackdrop,\n      //   backdropClass: this._popover.backdropClass,\n      //   scrollStrategy: this._popover.scrollStrategy,\n      //   forceAlignment: this._popover.forceAlignment,\n      //   lockAlignment: this._popover.lockAlignment,\n      //   panelClass: this._popover.panelClass\n      // };\n      // const overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);\n      // this._getPositionStrategy(\n      //   config.horizontalAlign,\n      //   config.verticalAlign,\n      //   config.forceAlignment,\n      //   config.lockAlignment,\n      //   anchor\n      // )\n      // const strategy = state.positionStrategy as FlexibleConnectedPositionStrategy;\n      // strategy.setOrigin(this._anchor);\n      // let overlayRef:OverlayRef  = this._overlay.create(state);\n      // overlayRef.updatePosition();\n\n      if (this._anchor === 'bottom') {\n        state.positionStrategy = this._overlay.position().global().centerHorizontally().bottom('0'); // .top('0');\n      } else {\n        state.positionStrategy = this._overlay.position().global().centerHorizontally() // .bottom('0');\n        .top('0');\n      }\n\n      return this._overlay.create(state);\n    }\n    /** Realign the popover to the anchor. */\n\n\n    realignToAnchor(overlayRef) {\n      if (overlayRef) {\n        const config = overlayRef.getConfig();\n        const strategy = config.positionStrategy;\n        strategy.reapplyLastPosition();\n      }\n    }\n\n  }\n\n  MatKeyboardService.ɵfac = function MatKeyboardService_Factory(t) {\n    return new (t || MatKeyboardService)(i0.ɵɵinject(i1.Overlay), i0.ɵɵinject(i2.LiveAnnouncer), i0.ɵɵinject(LOCALE_ID), i0.ɵɵinject(MAT_KEYBOARD_LAYOUTS), i0.ɵɵinject(MatKeyboardService, 12));\n  };\n\n  MatKeyboardService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: MatKeyboardService,\n    factory: MatKeyboardService.ɵfac\n  });\n  return MatKeyboardService;\n})();","map":null,"metadata":{},"sourceType":"module"}